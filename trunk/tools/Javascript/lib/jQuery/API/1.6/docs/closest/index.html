<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv='content-type' content='text/html; charset=UTF-8' /><title>jQuery 1.6  API 中文版 -- 前端攻城师</title></head><body>
<div class="entry-content">
        <div class="entry-title roundTop">
                    
				  <h1 class="jq-clearfix">.closest()</h1>
  				<div class="entry-meta">Categories:
  					<span class="category"><a   target="_blank" href="http://api.jquery.com/category/traversing/" title="View all posts in Traversing">Traversing</a> &gt; <a   target="_blank" href="http://api.jquery.com/category/traversing/tree-traversal/" title="View all posts in Tree Traversal">Tree Traversal</a></span>
  
  				</div>
</div>

<fieldset class="toc">
<legend>Contents:</legend>
<ul class="toc-list">
<li>
<a href="#closest1">closest( selector ) </a><ul>
<li>.closest( selector )
              </li>
<li>.closest( selector, [ context ] )
              </li>
</ul>
</li>
<li>
<a href="#closest2">closest( selectors, [ context ] ) </a><ul><li>.closest( selectors, [ context ] )
              </li></ul>
</li>
</ul>
</fieldset>
<div id="closest1" class="entry method">
<h2 class="jq-clearfix roundTop section-title">
<span class="name">.closest( selector )</span> <span class="returns">返回： <a class="return" href="http://docs.jquery.com/Types#jQuery">jQuery</a></span>
</h2>
<div class="jq-box roundBottom entry-details">
<p class="desc"><strong>描述： </strong>从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素。</p>
<ul class="signatures">
<li class="signature" id="closest-selector">
<h4 class="name">
<span class="versionAdded">version added: <a href="/category/version/1.3/">1.3</a></span>.closest( selector )</h4>
<p class="arguement"><strong>selector</strong>一个用于匹配元素的选择器字符串。</p>
</li>
<li class="signature" id="closest-selector-context">
<h4 class="name">
<span class="versionAdded">version added: <a href="/category/version/1.4/">1.4</a></span>.closest( selector, [ context ] )</h4>
<p class="arguement"><strong>selector</strong>一个用于匹配元素的选择器字符串。</p>
<p class="arguement"><strong>context</strong>DOM元素在其中一个匹配的元素可以被发现。如果没有上下文在当时的情况下通过了jQuery设置将被使用。</p>
</li>
<li class="signature" id="closest-jQuery object">
<h4 class="name">
<span class="versionAdded">version added: <a href="/category/version/1.6/">1.6</a></span>.closest( jQuery object )</h4>
<p class="arguement"><strong>jQuery object</strong>一个用于匹配元素的jQuery对象。</p>
</li>
<li class="signature" id="closest-element">
<h4 class="name">
<span class="versionAdded">version added: <a href="/category/version/1.6/">1.6</a></span>.closest( element )</h4>
<p class="arguement"><strong>element</strong>一个用于匹配元素的DOM元素。</p>
</li>
</ul>
<div class="longdesc">
<p>鉴于一个jQuery对象，表示一个DOM元素的集合，<code>.closest()</code>方法允许我们能够通过搜索这些元素和DOM树，并在他们的祖先从匹配的元素构造一个新的jQuery对象。<code>.parents()</code>和<code>.closest()</code>方法类似，它们都在DOM树遍历了。两者之间的差异，尽管细微，是重要的：
</p>
<table border="1" cellpadding="5" cellspacing="10">
<thead><tr>
<th width="330">.closest()</th>
  	  <th width="35">&nbsp;</th>
  	  <th>.parents()</th>
  	</tr>
</thead>
<tbody>
<tr>
<td>开始于当前元素</td>
  	  <td>&nbsp;</td>
  	  <td>开始于父元素</td>
</tr>
<tr>
<td>向上遍历DOM树，直到它找到一个匹配的供选择</td>
  	  <td>&nbsp;</td>
  	  <td>向上遍历DOM树到文档的根元素，每个祖先元素加入到临时集合，而是一个选择器，过滤器的基础上，如果一个是该集合提供 </td>
  	  </tr>
<tr>
<td>返回的jQuery对象包含零个或一个元素
</td>
  	  <td>&nbsp;</td>
  	  <td>返回的jQuery对象包含零个，一个或多个元素 </td>
  	</tr>
</tbody>
</table>
<pre>
  &lt;ul id="one" class="level-1"&gt;
    &lt;li class="item-i"&gt;I&lt;/li&gt;
    &lt;li id="ii" class="item-ii"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>假设我们从项目 A开始执行一个搜索<code>&lt;ul&gt;</code>：</p>
<pre>
$('li.item-a').closest('ul')
  .css('background-color', 'red');
</pre>
<p>这将改变level-2 <code>&lt;ul&gt;</code>的颜色，因为当向上遍历DOM树时，这是第一次遇到的匹配元素。</p>
<p>假设我们是一个搜索<code>&lt;li&gt;</code>元素来代替：</p>
<pre>$('li.item-a').closest('li')
  .css('background-color', 'red');
</pre>
<p>这将改变一个列表项A的颜色。<code>.closest()</code>方法开始从元素本身开始前进了DOM树的遍历，项目A时停止匹配选择。</p>
<p>我们可以传递一个DOM元素作为上下文在其中搜索最近的元素的。</p>
<pre>var listItemII = document.getElementById('ii');
$('li.item-a').closest('ul', listItemII)
  .css('background-color', 'red');
$('li.item-a').closest('#one', listItemII)
  .css('background-color', 'green');</pre>
<p>这将改变level-2 <code>&lt;ul&gt;</code>的颜色 </p>
<p>这将改变level-2 <code>&lt;ul&gt;</code>的颜色,因为它既是项目A的第一个<code>&lt;ul&gt;</code>祖先又是项目II的一个后裔。它将不会改变level-1 <code>&lt;ul&gt;</code>的 颜色 ，因为它不是项目II的后裔。</p>
</div>
<h3>Example:</h3>
<div class="entry-examples" id="entry-examples"><div id="example-0">
<h4><span class="desc">显示什么样的事件委托能用closest完成。closest 列表元素或者其后代被点击进行切换一个黄色的背景。</span></h4>
<pre><code class="example demo-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
  li { margin: 3px; padding: 3px; background: #EEEEEE; }
  li.hilight { background: yellow; }
  &lt;/style&gt;
  &lt;script src="http://code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul&gt;
&lt;li&gt;&lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;You can also &lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;

    $(document).bind("click", function (e) {
      $(e.target).closest("li").toggleClass("hilight");
    });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4>Demo:</h4>
<div class="demo code-demo"></div>
</div></div>
<div id="example-1">
<h4>Example: <span class="desc">传递一个jQuery对象给closest. closest 列表元素或者其后代被点击进行切换一个黄色的背景。</span>
</h4>
<pre class="prettyprint"><code class="example demo-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;
  li { margin: 3px; padding: 3px; background: #EEEEEE; }
  li.hilight { background: yellow; }
  &lt;/style&gt;
  &lt;script src="http://code.jquery.com/jquery-git.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;You can also &lt;b&gt;Click me!&lt;/b&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;script&gt;
  var $listElements = $("li").css("color", "blue");
  $( document ).bind("click", function( e ) {
    $( e.target ).closest( $listElements ).toggleClass("hilight");
  });
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4>Demo:</h4>
<div class="demo code-demo"></div>
</div>
</div>
</div>
<div id="closest2" class="entry method">
<h2 class="jq-clearfix roundTop section-title">
<span class="name">.closest( selectors, [ context ] )</span> <span class="returns">返回： <a class="return" href="http://docs.jquery.com/Types#Array">Array</a></span>
</h2>
<div class="jq-box roundBottom entry-details">
<p class="desc"><strong>描述： </strong>从元素本身开始，逐级向上级元素匹配，并返回最先匹配的祖先元素。</p>
<ul class="signatures"><li class="signature" id="closest-selectors-context">
<h4 class="name">
<span class="versionAdded">version added: <a href="/category/version/1.4/">1.4</a></span>.closest( selectors, [ context ] )</h4>
<p class="arguement"><strong>selector</strong>一个用于匹配元素的选择器字符串。</p>
<p class="arguement"><strong>context</strong>DOM元素在其中一个匹配的元素可以被发现。如果没有上下文在当时的情况下通过了jQuery设置将被使用。</p>
</li></ul>
<div class="longdesc"><p>这种方法主要是为了内部使用或插件作者。
</p></div>
<h3>Example:</h3>
<div class="entry-examples" id="entry-examples-1"><div id="example-1-0">
<h4><span class="desc">Show how event delegation can be done with closest.</span></h4>
<pre><code class="example demo-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;style&gt;&lt;/style&gt;
  &lt;script src="http://code.jquery.com/jquery-latest.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;script&gt;var close = $("li:first").closest(["ul", "body"]);
        $.each(close, function(i){
  $("li").eq(i).html( this.selector + ": " + this.elem.nodeName );
});&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h4>Demo:</h4>
<div class="demo code-demo"></div>
</div></div>
</div>
</div>


				</div>

<div class="copy"><a href="http://julying.com/jQuery-1.6-api/" title="jQuery 1.6 API 中文版">jQuery 1.6 API 中文版</a>由<a href="http://julying.com/" target="_blank" title="前端攻城师">前端攻城师</a>整理、修订 (2011年6月)</div></body></html>